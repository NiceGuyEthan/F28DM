<data>

<!--UPDATE WITH YOUR USERNAME -->
    <USERNAME>tr2080</USERNAME>

<!--START OF EXAMPLE -->
    <question id="0">
        <answer>1094</answer>
        <sql>
            SELECT COUNT(*) FROM trajectory.tracking;
        </sql>
    </question>
<!--END OF EXAMPLE -->

<!--START OF YOUR ANSWERS and SQL STATEMENTS-->

    <question id="1">
        <answer>The Lodger (1898)</answer>
        <sql>
            SELECT title 
            FROM imdb.movies 
            WHERE year = (SELECT MIN(year) FROM imdb.movies);
        </sql>
    </question>

    <question id="2">
        <answer>2</answer>
        <sql>
    SELECT COUNT(*) AS num_movies
    FROM (
    SELECT movieid
    FROM imdb.movies2directors
    GROUP BY movieid
    HAVING COUNT(directorid) > 7
    ) AS sub;
        </sql>
    </question>

    <question id="3">
        <answer>1940</answer>
        <sql>
       SELECT m.year 
       FROM imdb.movies m
       JOIN imdb.movies2directors md ON m.movieid = md.movieid
       GROUP BY m.movieid, m.year
       ORDER BY COUNT(md.directorid) DESC
       LIMIT 1;
        </sql>
    </question>

    <question id="4">
        <answer>2500324</answer>
        <sql>
        SELECT actorid
        FROM imdb.movies2actors
        WHERE movieid IN (
        SELECT movieid
        FROM imdb.movies2actors
        WHERE actorid = (
        SELECT actorid
        FROM imdb.actors
        WHERE name = 'Hanks, Tom'
        )
        )
        AND actorid != (
        SELECT actorid
        FROM imdb.actors
        WHERE name = 'Hanks, Tom'
        )
        GROUP BY actorid
        ORDER BY SUM(1) DESC
        LIMIT 1;
        </sql>
    </question>

    <question id="5">
        <answer>3</answer>
        <sql>
      <![CDATA[ SELECT COUNT(*) 
      FROM (SELECT m2a1.actorid AS actor1, m2a2.actorid AS actor2, COUNT(*) AS films_together
      FROM imdb.movies2actors m2a1
      JOIN imdb.movies2actors m2a2 ON m2a1.movieid = m2a2.movieid
      WHERE m2a1.actorid < m2a2.actorid
      GROUP BY m2a1.actorid, m2a2.actorid
      HAVING COUNT(*) > 10) AS subquery;
            ]]>
        </sql>
    </question>

    <question id="6">
        <answer>1930</answer>
        <sql>
        SELECT (year / 10) * 10 AS decade
        FROM imdb.movies m
        JOIN imdb.ratings r ON m.movieid = r.movieid
        GROUP BY decade
        ORDER BY AVG(CAST(r.rank AS double precision)) DESC
        LIMIT 1;
        </sql>
    </question>

    <question id="7">
        <answer>32</answer>
        <sql>
       SELECT COUNT(DISTINCT m.movieid)
       FROM imdb.movies m
       LEFT JOIN imdb.movies2directors md ON m.movieid = md.movieid
       WHERE md.genre IS NULL OR TRIM(md.genre) = '';
        </sql>
    </question>

    <question id="8">
        <answer></answer>
        <sql>
       
        </sql>
    </question>

    <question id="9">
        <answer></answer>
        <sql>
       
        </sql>
    </question>

    <question id="10">
        <answer></answer>
        <sql>
       
        </sql>
    </question>

    <question id="11">
        <answer>74</answer>
        <sql>
       SELECT COUNT(*) AS num_locations_within_5km
       FROM scenicornot.locations
       WHERE ST_DWithin(
       geom_bng,
       ST_SetSRID(ST_MakePoint(530000, 180000), 27700),
       5000
       );
        </sql>
    </question>

    <question id="12">
        <answer>616</answer>
        <sql>
       SELECT h.cell_id, AVG(l.average) AS avg_score, COUNT(*) AS location_count
       FROM scenicornot.hexgrid10km h
       JOIN scenicornot.locations l
       ON ST_Contains(h.geom, l.geom_bng)
       GROUP BY h.cell_id
       HAVING COUNT(*) >= 3
       ORDER BY avg_score DESC
       LIMIT 1;
        </sql>
    </question>

    <question id="13">
        <answer>2222</answer>
        <sql>SELECT h.cell_id,
       SUM(array_length(string_to_array(l.votes, ','), 1)) AS total_votes
       FROM scenicornot.hexgrid10km h
       JOIN scenicornot.locations l
       ON ST_Contains(h.geom, l.geom_bng)
       GROUP BY h.cell_id
       ORDER BY total_votes DESC
       LIMIT 1;       
        </sql>
    </question>

    <question id="14">
        <answer>1618, 1688</answer>
        <sql>
       <![CDATA[ WITH avg_scores AS (
       SELECT h.cell_id, AVG(l.average) AS avg_score
       FROM scenicornot.hexgrid10km h
       JOIN scenicornot.locations l ON ST_Contains(h.geom, l.geom_bng)
       GROUP BY h.cell_id
       ),
       neighbour_pairs AS (
       SELECT a.cell_id AS cell_a, b.cell_id AS cell_b,
       ABS(a.avg_score - b.avg_score) AS score_diff
       FROM avg_scores a
       JOIN avg_scores b
       ON a.cell_id < b.cell_id
       AND ST_Touches(
       (SELECT geom FROM scenicornot.hexgrid10km WHERE cell_id = a.cell_id),
       (SELECT geom FROM scenicornot.hexgrid10km WHERE cell_id = b.cell_id)
       )
       )
       SELECT cell_a, cell_b
       FROM neighbour_pairs
       ORDER BY score_diff DESC
       LIMIT 1;
            ]]>
        </sql>
    </question>

    <question id="15">
        <answer>8</answer>
        <sql>
        WITH quake_periods AS (
        SELECT 
        DATE_TRUNC('hour', '2010-01-01 00:00:00'::timestamp + 
        INTERVAL '48 hours' * FLOOR(EXTRACT(EPOCH FROM (datetime - '2010-01-01 00:00:00'::timestamp)) / (48 * 3600))) 
        AS period_start,
        COUNT(*) AS quake_count
        FROM quakes.scotquakes
        GROUP BY period_start
        )
        SELECT period_start AS start_time, quake_count
        FROM quake_periods
        ORDER BY quake_count DESC
        LIMIT 1; 
        </sql>
    </question>

    <question id="16">
        <answer>10</answer>
        <sql>
            SELECT COUNT(DISTINCT s.fid) AS unique_scenicornot_locations
            FROM scenicornot.locations s
            JOIN quakes.scotquakes q
            ON ST_DWithin(
            s.geom_bng,
            ST_Transform(q.geom, 27700),
            100  
            ); 
        </sql>
    </question>

    <question id="17">
        <answer>33</answer>
        <sql>
            WITH clusters AS (
            SELECT 
            ST_ClusterDBSCAN(geom, eps := 15000, minpoints := 5) OVER () AS cluster_id
            FROM quakes.scotquakes
            )
            SELECT COUNT(DISTINCT cluster_id) AS num_clusters
            FROM clusters
            WHERE cluster_id IS NOT NULL AND cluster_id != -1;
        </sql>
    </question>

    <question id="18">
        <answer>1.17</answer>
        <sql>
       SELECT AVG(spd) AS average_speed
       FROM trajectory.tracking
       WHERE userid = 'p3';
        </sql>
    </question>

    <question id="19">
        <answer>p1</answer>
        <sql>
       SELECT userid, routeid, COUNT(*) AS num_points
       FROM trajectory.tracking
       GROUP BY userid, routeid
       ORDER BY num_points DESC
       LIMIT 1;
        </sql>
    </question>

    <question id="20">
        <answer>p3</answer>
        <sql> 
         SELECT 
         userid,
         ST_Length(ST_MakeLine(geom ORDER BY datetime)::geography) / 
         NULLIF(
         ST_Distance(
         ST_MakePoint(MIN(lng), MIN(lat))::geography,
         ST_MakePoint(MAX(lng), MAX(lat))::geography
         ), 0
         ) AS sinuosity_ratio
         FROM trajectory.tracking
         GROUP BY userid
         ORDER BY sinuosity_ratio DESC
         LIMIT 1;
        </sql>
    </question>

    <question id="21">
        <answer>1151.19</answer>
        <sql>
       SELECT SUM(ST_Distance(prev_geom::geography, geom::geography)) AS total_distance_meters
       FROM (
       SELECT 
       userid, 
       geom,
       LAG(geom) OVER (PARTITION BY userid ORDER BY datetime) AS prev_geom
       FROM trajectory.tracking
       WHERE userid = 'p1'
       ) AS ordered_points
       WHERE prev_geom IS NOT NULL;
        </sql>
    </question>

    <question id="22">
        <answer>08</answer>
        <sql>
            SELECT 
            EXTRACT(MONTH FROM date_taken) AS month, 
            COUNT(*) AS photo_count
            FROM flickr.flickr_edin
            GROUP BY month
            ORDER BY photo_count DESC
            LIMIT 1;  
        </sql>
    </question>


    <question id="23">
        <answer>19473027@N00</answer>
        <sql>
            SELECT 
            f.userid, 
            COUNT(DISTINCT g.id) AS unique_locations
            FROM flickr.flickr_edin f
            JOIN flickr.grid100m g 
            ON ST_Intersects(f.geom, g.geom)
            GROUP BY f.userid
            ORDER BY unique_locations DESC
            LIMIT 1;
        </sql>
    </question>

    <question id="24">
        <answer></answer>
        <sql>
       SELECT osm_name, COUNT(DISTINCT osm_id) AS osm_id_count
       FROM accident.network
       WHERE osm_name ILIKE '%avenue%' 
       GROUP BY osm_name
       HAVING COUNT(DISTINCT osm_id) > 1;
        </sql>
    </question>

    <question id="25">
        <answer>b</answer>
        <sql>
       SELECT route,
       COUNT(e.id) / SUM(n.km) AS crashes_per_km
       FROM
       (SELECT 'a' AS route, geom FROM accident.route_a
       UNION ALL
       SELECT 'b' AS route, geom FROM accident.route_b
       UNION ALL
       SELECT 'c' AS route, geom FROM accident.route_c) r
       JOIN accident.edincrash e
       ON ST_DWithin(r.geom, e.geom, 15)  -- Check within 15 meters
       JOIN accident.network n
       ON ST_DWithin(r.geom, n.geom, 15)  -- Same distance check for the network
       GROUP BY route
       ORDER BY crashes_per_km DESC
       LIMIT 1;
        </sql>
    </question>


<!--END OF ANSWERS -->

</data>


